#include <tuple>
#include <mitsuba/core/ray.h>
#include <mitsuba/core/properties.h>
#include <mitsuba/render/bsdf.h>
#include <mitsuba/render/emitter.h>
#include <mitsuba/render/integrator.h>
#include <mitsuba/render/records.h>

NAMESPACE_BEGIN(mitsuba)

enum class VertexType : uint32_t {
    Camera = 0x0,
    Light = 0x1,
    Surface = 0x2,
};

MI_DECLARE_ENUM_OPERATORS(VertexType)

// need a huge vertex interface
template <typename Float, typename Spectrum>
struct Vertex {

    MI_IMPORT_TYPES()

    VertexType type;
    Spectrum β;

    SurfaceInteraction3f si;

    Bool δ = false;
    // probability per unit area of the current vertex as generated by the path sampling algorithm
    Float pdf_fwd = 0.f
    // the hypothetical probability density of the vertex if the direction of light transport was reversed
    Float pdf_rev = 0.f;

    DRJIT_STRUCT(Vertex, type, β, si, δ, pdf_fwd, pdf_rev)
};

template <typename Float, typename Spectrum>
class BDPTIntegrator final : public Integrator<Float, Spectrum> {
public:
    MI_IMPORT_BASE(Integrator)
    MI_IMPORT_TYPES(Scene, Sampler, Sensor, Emitter, BSDF, EmitterPtr, BSDFPtr)

    BDPTIntegrator(const Properties &props) : Base(props) {
        m_max_depth = props.get<uint32_t>("max_depth", 5);
        m_rr_depth = props.get<uint32_t>("rr_depth", 5);
    }

    void GenerateCameraSubpath(Scene *scene, Sampler *sampler, int maxDepth, std::vector<Vertex<Float, Spectrum>> &cameraVertices);

    void GenerateLightSubpath(Scene *scene, Sampler *sampler, int maxDepth, std::vector<Vertex<Float, Spectrum>> &lightVertices);

    void RandomWalk(Scene *scene,
            RayDifferential3f ray,
            Sampler *sampler,
            Spectrum β,
            Float pdfDir,
            UInt32 maxDepth,
            TransportMode mode

            // perform path sampling based on maxDepth
        );

    void ConnectBDPT(Scene *scene, Path *cameraPath, Path *lightPath, int s, int t, TensorXf &result);
    TensorXf render(const Scene *scene, Sensor *sensor) override {
        
        TensorXf result;
        // implement only for cpu type
if constexpr (!dr::is_jit_v<Float>) {
        
} else {
    else {
        Throw("SPPMIntegrator is not supported in JIT mode!");
}

    return result;
    }

    std::string to_string() const override {
        return tfm::format("BDPTIntegrator[\n"
            "]");
    }

    MI_DECLARE_CLASS()
private: 
    uint32_t m_max_depth,
        m_rr_depth;
};

MI_IMPLEMENT_CLASS_VARIANT(BDPTIntegrator, Integrator)
MI_EXPORT_PLUGIN(BDPTIntegrator, "BDPT integrator");
NAMESPACE_END(mitsuba)