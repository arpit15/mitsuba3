#include <tuple>
#include <mitsuba/core/ray.h>
#include <mitsuba/core/properties.h>
#include <mitsuba/render/bsdf.h>
#include <mitsuba/render/emitter.h>
#include <mitsuba/render/integrator.h>
#include <mitsuba/render/records.h>

NAMESPACE_BEGIN(mitsuba)

enum class VertexType : uint32_t
{
    Camera = 0x0,
    Light = 0x1,
    Surface = 0x2,
};

MI_DECLARE_ENUM_OPERATORS(VertexType)

// need a huge vertex interface
template <typename Float, typename Spectrum>
struct Vertex
{

    MI_IMPORT_TYPES()

    VertexType type;
    Spectrum β;

    SurfaceInteraction3f si;

    Bool δ = false;
    // probability per unit area of the current vertex as generated by the path sampling algorithm
    Float pdf_fwd = 0.f
        // the hypothetical probability density of the vertex if the direction of light transport was reversed
        Float pdf_rev = 0.f;

    DRJIT_STRUCT(Vertex, type, β, si, δ, pdf_fwd, pdf_rev)
};

template <typename Float, typename Spectrum>
class BDPTIntegrator final : public Integrator<Float, Spectrum>
{
public:
    MI_IMPORT_BASE(Integrator)
    MI_IMPORT_TYPES(Scene, Sampler, Sensor, Emitter, BSDF, EmitterPtr, BSDFPtr)

    BDPTIntegrator(const Properties &props) : Base(props)
    {
        m_max_depth = props.get<uint32_t>("max_depth", 5);
        m_rr_depth = props.get<uint32_t>("rr_depth", 5);
    }

    void GenerateCameraSubpath(Scene *scene, Sampler *sampler, int maxDepth);

    void GenerateLightSubpath(Scene *scene, Sampler *sampler, int maxDepth);

    void RandomWalk(Scene *scene,
                    RayDifferential3f ray,
                    Sampler *sampler,
                    Spectrum β,
                    Float pdfDir,
                    UInt32 maxDepth,
                    TransportMode mode

                    // perform path sampling based on maxDepth
    );

    UInt32 ConnectBDPT(Scene *scene, Path *cameraPath, Path *lightPath, int s, int t, TensorXf &result);
    TensorXf render(const Scene *scene, Sensor *sensor) override
    {

        TensorXf result;
        // implement only for cpu type
        if constexpr (!dr::is_jit_v<Float>)
        {
            auto camera_verts = GenerateCameraSubpath(scene, sensor);
            auto light_verts = GenerateLightSubpath(scene, sensor);

            Spectrum L(0.f);
            // execute all BDPT connection strategies
            for (int t = 1; t <= camera_verts.size(); ++t)
            {
                for (int s = 0; s <= light_verts.size(); ++s)
                {
                    if ((s == 1 && t == 1) || depth < 0 || depth > m_max_depth)
                        continue;

                    // execute (s,t) connection strategy and update L
                    auto Lpath = ConnectBDPT(scene, sensor, lambda, light_verts, camera_verts, s, t);

                    if (t != 1)
                        L += Lpath;
                    else if (Lpath)
                    {
                        // do splatting
                    }
                }
            }
        }
        else
        {
            else
            {
                Throw("SPPMIntegrator is not supported in JIT mode!");
            }

            return result;
        }

        std::string to_string() const override
        {
            return tfm::format("BDPTIntegrator[\n"
                               "]");
        }

        MI_DECLARE_CLASS()
    private:
        uint32_t m_max_depth,
            m_rr_depth;
    };

    MI_IMPLEMENT_CLASS_VARIANT(BDPTIntegrator, Integrator)
    MI_EXPORT_PLUGIN(BDPTIntegrator, "BDPT integrator");
    NAMESPACE_END(mitsuba)